---
layout: default
---

## 激光雷达Lidar3D物体对象检测

### 1. 介绍

为了做出决策、执行路径规划或发出制动操作，自动驾驶汽车需要识别周围环境中的相关物体对象。这些对象是各种类型的车辆（例如汽车、卡车、拖车）、骑自行车的人、行人、车道边界、道路标志等。

在计算机视觉中，深度学习方法通常用于检测和分类场景中的相关对象。 在下图中，YOLO检测框架已检测到人和车辆并正确分类。

![image](https://qqsj789.github.io/img//c2-2-img1.png)

基于深度学习的检测和分类主要应用于二维图像处理领域。近年来，基于3D点云的深度学习已经引起了学术界和汽车行业的关注。特别是在过去的四五年中，用于解决点云处理相关问题的已发布方法的数量显著增加。

与图像相比，基于3D点云的深度学习一直面临着挑战，例如：

- 区别于相机拍摄的图像总是有相同数量的像素，点云作为点在场景中的位置具有稀疏和非结构化的性质，因此点云的密度和数量随场景中物体的存在而变化。
- 区别于一般图像检测分类对实时性没有太高要求，自动驾驶汽车需要非常快速的反应，目标检测实时性要求很高，这意味着检测网络必须在两次扫描的时间间隔内提供结果。

### 2. 最先进的 3D 物体对象检测方法

深度学习应用于基于3D点云的物体对象检测和分类由三个主要部分组成：(1)数据表示，(2)特征提取，(3)基于模型的检测。下图为端到端进行3D点云物体对象检测和分类流程:

![Typical object detection pipeline - 3D point cloud to data representation, to feature extraction, to detection and prediction refinement, and finally the detected vehicles](https://qqsj789.github.io/img//c2-2-img2.png)

第一部分，激光雷达传感器提供的点云被组织成适合在后续阶段有效处理数据的结构。在现有的研究中，存在两种主要的数据表示方法:要么将点云转换为“体素”、“柱”或“截锥”等结构，要么保留原始点云并直接处理。

第二部分是特征提取，从变换后的点云中提取不同类型的低维和高维特征，现在可以表示为网格中的二维鸟瞰图。一旦一组特征被检测到，结果被转发到实际的检测网络。

第三部分代表实际的检测网络，负责物体检测。该步骤包括对象类别预测、检测对象周围的边界框回归和对象方向的确定等。


#### 2.1 数据表示

激光雷达点云是一种非结构化的数据点,它们在测量范围内分布不均。随着卷积神经网络 (CNN) 在对象检测中的普及，点云需要表示为具有适合CNN网络结构的数据，以便可以有效地应用卷积运算。以下是通常表示点云数据的方法：

##### 基于点的数据表示

基于点的方法采用原始和未过滤的输入点云并将其转换为稀疏表示，这本质上对应于聚类操作，基于某些标准（例如空间距离）将点分配给同一聚类。此类数据表示方法在特征提取时通过考虑相邻集群为每个点提取特征向量。这种方法通常先为每个单点寻找低维局部特征，然后将它们聚合成更大更复杂的高维特征。这类方法最突出的代表之一是 Qi 等人的PointNet，它激发了许多其他重要贡献，例如 PointNet++ 或LaserNet。基于点的数据表示方法主要优点之一是它们保持点云的结构完好无损，因此不会丢失任何信息。基于点的方法缺点之一是对内存资源的需求相对较高，因为必须通过处理管道传输大量点云数据。

##### 基于体素的数据表示（Voxel-based data representation）

体素被定义为空间中三维网格中的体积元素。基于体素的方法将输入点云中的每个点分配给特定的体积元素。根据体素网格的粗糙度，多个点可能落在同一个体积元素内。在下一步中，从每个体素内的点组中提取局部特征。基于体素的方法最显着的优点之一是节省内存资源，因为它们减少了必须同时保存在内存中的元素数量。因此，特征提取网络的计算效率会更高，因为特征是为一组体素提取的，而不是为每个点单独提取。这类算法的一个著名代表是 VoxelNet。下图显示了一个点云，其各个点根据它们的空间接近度进行聚类并分配给体素。操作完成后，表示对象的数据量明显减少。

![Voxel-based data representation](https://qqsj789.github.io/img//sdcnd-c2-2-img3.png)

##### 基于支柱的数据表示

一种非常类似于基于体素数据表示的方法是基于柱的方法。在这里，点云不是聚集成立方体的体积元素，而是聚集成从地面向上上升的垂直柱。

![Pillar-based data representation](https://qqsj789.github.io/img//sdcnd-c2-2-img4.png)

与基于体素的方法一样，将点云分割成离散的体积元素可以节省内存资源——对于柱子更是如此，因为柱子通常比体素少得多。此类中一个著名的检测算法是 PointPillars。

##### 基于视锥体的数据表示（Frustum-based data representation）

当与其他传感器（如相机）结合使用时，激光雷达点云可以根据预先检测到的 2d 对象（如车辆或行人）进行聚类。如果物体在图像平面上的投影周围的 2d 区域是已知的，则可以使用相机的内部和外部校准将视锥体投影到 3D 空间中。属于此类的一种方法是Frustum PointNets。下图说明了原理。

![Frustum-based data representation](https://qqsj789.github.io/img//sdcnd-c2-2-img5.png)

与以前的方法相比，这种方法的一个明显缺点是它需要第二个传感器，例如相机。然而，由于相机已经广泛用于自动驾驶中的物体检测，这不是一个明显的缺点。

##### 基于投影的数据表示（Projection-based data representation）

虽然基于体素和基于柱的算法都基于空间邻近性度量对点云进行聚类，但基于投影的方法会沿指定维度降低 3D 点云的维数。在文献中，可以确定三种主要方法，即前视图 (FV)、范围视图 (RV) 和鸟瞰图 (BEV)。在 FV 方法中，点云沿前向轴被压缩，而在 BEV 图像中，点被投影到地平面上。下图说明了这两种方法。

![Projection-based data representation - front view vs bird's eye view](https://qqsj789.github.io/img//c2-2-img6.png)

RV 方法与 FV 方法非常相似，不同之处在于点云不是投影到平面上，而是投影到全景视图上。这个概念是在 Waymo 数据集中实现的，其中激光雷达数据存储为距离图像。

在文献中，BEV是最广泛使用的投影方案。主要原因是：
- 感兴趣的物体与配备传感器的车辆位于同一平面上，差异很小。
- BEV投影保留了物体之间的物理尺寸和邻近关系，比 FV 和 RV 投影更清晰地将它们分开。

#### 2.2 特征提取

在点云转换为合适的表示（例如 BEV 投影）后，下一步是识别合适的特征。目前，特征提取是最活跃的研究领域之一，并且在过去几年取得了重大进展，特别是在提高目标检测器模型的效率方面。

最常用的特征类型是：局部、全局和上下文特征。

- 局部特征通常被称为低级特征，在非常早期的处理阶段获得，它包含精确的信息，例如关于数据表示结构中单个元素的定位。
- 全局特征，也称为高级特征，通常在数据表示结构中编码元素与其相邻元素的几何结构。
- 上下文特征在最后处理阶段提取。这些特征旨在准确定位并具有丰富的语义信息，例如对象类别、边界框形状和大小以及对象的方向。

以下是当前流行的一些特征提取器：

##### 逐点特征提取器（Point-wise feature extractors）

术语“逐点”是指将整个点云用作输入。这种方法显然适用于从第一步开始的基于点的数据表示。逐点特征提取器单独分析和标记每个点，例如在 PointNet 和 PointNet++ 中，它们是目前知名的特征提取器。为了说明原理，先简单看一下PointNet架构，如下图所示：

![PointNet architecture](https://qqsj789.github.io/img//c2-2-img7.png)

PointNet使用整个点云作为输入。它从欧几里得空间中的点子集中每个点的空间特征中提取全局结构。为了实现这一点，PointNet实现了一个由三个主要块组成的非层次神经网络，这三个主要块是一个最大池层，一个用于结合局部和全局信息的结构，以及两个用于将输入点与提取的点特征对齐的网络。在图中，N是指输入 PointNet 的点数，Y是特征的维度。为了逐点提取特征，使用一组多层感知器 (MLP) 将每个N点从三个维度 (x, y, z) 映射到 64 维。重复此过程以将 N点从 64 维映射到 M=1024维。完成后，最大池化用于创建全局特征向量${R}^{1024}$。最后，使用三层全连接网络映射全局特征向量以生成对象分类和对象位置。 

PointNet 的缺点之一是它无法捕获相邻点之间的局部结构信息，因为每个点的特征都是单独学习的，而点之间的关系被忽略。在 PointNet++ 中改进了这一缺点。尽管逐点特征提取器显示出非常有希望的结果，但由于高内存要求和计算复杂性，它们尚不适合用于自动驾驶。

##### 分割特征提取器（Segment-wise feature extractors）

由于基于点的特征提取计算复杂度很高，因此需要替代方法可以在实时环境中使用激光雷达点云中的对象检测。术语“分割”指的是如何将点云划分为空间集群（例如体素、柱或截锥体）。完成此操作后，将分类模型应用于分割出的每个点以提取合适的体积特征。这类特征提取器中被引用最多的代表之一是 VoxelNet。简而言之，VoxelNet 的思想是通过称为“体素特征提取器 (VFE)”的架构对每个体素进行编码，然后使用 3D 卷积层组合局部体素特征，然后将点云转换为高维体积表示。最后，区域提议网络处理体积表示并输出实际检测结果。

![VoxelNet processing pipeline - divide into voxels, feed to a feature learning network, then to convolutional middle layers, and out to a region proposal network](https://qqsj789.github.io/img//sdcnd-c2-2-img8.png)

为了说明这个概念，下图显示了上图所示特征学习网络中的体素特征提取器的架构：

![Voxel Feature Extractor](https://qqsj789.github.io/img//sdcnd-c2-2-img9.png)



##### 卷积神经网络 (CNN)

多年来，CNN 已成功用于检测和分类相机图像中的对象。Krizhevsky 等人于 2012 年发表了第一篇具有里程碑意义的论文，该论文表明基于 CNN 的图像分类优于当时最先进的方法，例如支持向量机 (SVM)。近年来，许多基于图像的目标检测方法已成功转移到点云处理。

在基于 CNN 的对象检测方法中，处理管道在很大程度上依赖于“骨干网络”的使用，这些网络作为提取特征的基本元素。这种方法允许自适应和自动识别特征，而无需像许多经典方法一样投入手动（因此通常是启发式）工程工作。在大多数情况下，用于基于图像的对象检测的骨干网络也可以直接用于点云。为了在检测精度和效率之间取得平衡，可以在更深且连接密集的网络或连接很少的轻量级变体之间选择主干的类型。

尽管当时使用 AlexNet 等 CNN 取得的结果令人惊叹，但这些网络存在的问题是，随着网络深度的增加，检测精度变得饱和并迅速下降，这是被称为“梯度消失”的问题。这个问题通常发生在所有具有大量层的架构中，即在所有“深度”网络中。为了克服这个问题，He 等人提出了 ResNet 架构。它使用“跳过连接”（即快捷方式）将一层的值直接传递到下一层，而不使用非线性变换。通过使用此类捷径，可以直接传播梯度，从而显着降低训练难度。这意味着可以在不影响模型训练能力的情况下增加网络深度。

#### 2.3 物体对象检测

一旦从输入数据中提取了特征，就需要一个检测网络来生成上下文特征（例如对象类、边界框）并最终输出模型预测。根据不同的检测网络架构，检测过程可以大致分为两类，一类是两步检测编码器，如 R-CNN、Faster R-CNN 或 PointRCNN，另一类是一步检测编码器，如 YOLO 和 SSD。一般来说，一步检测编码器比两步检测编码器更快，这使得它们更适合自动驾驶等实时应用。

基于 CNN 的对象检测面临的一个问题是我们不知道输入数据中有多少特定对象类型的实例。点云中可能只有一辆车可见，也可能是 10 辆车。解决这个问题的一种简单方法是将 CNN 应用于多个区域，并分别检查每个区域内是否存在对象。但是，由于对象具有不同的位置和形状，因此必须选择大量区域，这在计算上很快变得不可行。

为了解决这个问题，Ross Girshick等人提出了一种方法 (R-CNN)，其中使用选择性搜索来提取约 2000 个区域，他称之为区域提议。这意味着需要分类的区域数量显着减少。请注意，在原始论文中，输入数据是相机图像而不是点云。然后将候选区域输入 CNN 以生成高维特征向量，使用支持向量机 (SVM) 从中推断候选区域内对象的存在。下图说明了该过程

![R-CNN with region proposal function](https://qqsj789.github.io/img//sdcnd-c2-2-img10.png)

为了细化预测并提高模型输出的准确性，两步检测编码器将第一阶段的结果馈送到额外的检测网络，该网络通过组合不同的特征类型以产生细化结果来细化预测。

另外一种物体对象检测方法，一步检测器在一个步骤中执行区域提议、分类和边界框回归，这使得它们明显更快，因此更适合实时应用。在许多情况下，两步检测器往往会达到更好的精度。

最著名的一步检测器是 YOLO（你只需看一次）。该模型在输入数据上运行深度学习 CNN 以生成预测。对象检测器解码预测并生成边界框，如下图所示：

![YOLO object detection with prediction decoder](https://qqsj789.github.io/img//sdcnd-c2-2-img11.png)

YOLO 使用锚框来检测对象的类别，这些对象是具有特定高度和宽度的预定义边界框。这些框被定义为捕获特定对象类别（例如车辆、行人）的比例和纵横比，并且通常根据训练数据集中的对象大小进行选择。在检测过程中，预定义的锚框在图像上平铺。该网络预测每个平铺锚框的概率和其他属性，例如背景、联合交集 (IoU) 和偏移量。预测用于细化每个单独的锚框。

使用锚框时，可以一次评估所有对象预测，而无需像许多经典应用程序那样使用滑动窗口。使用锚框的物体检测器可以一次处理整个输入数据，从而使实时物体检测系统成为可能。

![YOLO anchor boxes and feature vector](https://qqsj789.github.io/img//sdcnd-c2-2-img12.png)

YOLO网络为每个定义的锚框返回一组唯一的预测。最终的特征图代表每个类的对象检测。锚框的使用使网络能够检测多个对象、不同尺度的对象和重叠对象。

如前所述，大多数基于 CNN 的方法最初来自计算机视觉领域，并且在开发时考虑了基于图像的检测。因此，为了将这些方法应用于激光雷达点云，必须将 3d 点转换为 2d 图像。
### 3. 实时3D点云对象检测（Real-time 3D Object Detection on Point Clouds）

#### 3.1 复合YOLO算法简介

M. Simon等人在Complex-YOLO: Point Clouds上的实时三维物体检测(Real-time 3D Object Detection on Point Clouds)一文中将二维图像对象边界框检测网络YOLO扩展到三维点云。由下图可以看出，Complex YOLO的主管道由三个步骤组成：

![Complex YOLO detection pipeline - point cloud to bird's eye view, then complex YOLO onto that BEV map, and finally re-converting the 3D bounding boxes](https://qqsj789.github.io/img//sdcnd-c2-3-img1.png)

#### 3.2 点云转化为鸟瞰图（BEV)

首先，将 3D 点云转换为鸟瞰图（BEV），通过沿向上轴（Waymo 车辆坐标系中的 z 轴）压缩点云来实现。BEV 被划分为由大小相等的单元组成的网格，这使我们能够将其视为图像，其中每个像素对应路面上的一个区域。从下图可以看出，几个单独的点往往落入同一个网格元素中，尤其是在与路面正交的表面上。下图说明了这个概念：

![Point cloud superimposed on the BEV grid cells](https://qqsj789.github.io/img//c2-3-img2.png)

可以看出，点的密度在单元之间变化很大，这取决于场景中物体的存在。在路面上，由于垂直方向的角分辨率（64 束激光束），点的数量相对较少，由于相邻垂直 LED 的反射，从同样的距离来看，车辆正面、背面或侧面的点数量要多得多。这意味着我们可以为每个 BEV 单元导出三条信息，即点的强度、高度和密度。因此，生成的 BEV 地图将具有三个通道，从检测网络的角度来看，这使其成为彩色图像。

BEV图的生成过程如下：

- 设置包含的区域。可以把纵向范围设置为 0—50m，横向范围设置为 -25—+25m。选择这组特定参数的基本原理部分基于原始论文以及 Complex YOLO 现有实现中的设计选择。

- 设置BEV 图像的分辨率以及单个网格单元的大小划分区域为网格。可以将 BEV 图像的大小设置为 608 x 608 像素，这可以计算空间分辨率约为 8cm。

- 识别位于每个单元格中的点 $P_{i,j}$集合，其中$i,j$是各自的单元格坐标，使用$N {i,j}$来表示单元格中点的数量。
  
 Height $$ H_{i,j} = \max\left(P_{i,j} \cdot \left[0,0,1\right]T\right)$$
            
 Intensity $I_{i,j} = \max\left(I\left(P_{i,j}\right)\right)$
       
 Density  $D_{i,j} = \min\left( 1.0, \frac{\log(N+1)}{64}\right)$
       
       
$H_{i,j}$表示最大高度，$I_{i,j}$ 表示最大强度，$D_{i,j}$表示映射到单元格中的所有点的标准化密度。生成的BEV图像如下所示：

![BEV channels - height, intensity and density](https://qqsj789.github.io/img//c2-3-img3-16328954006872.png)

在左上角可以看到叠加了所有三个通道的 BEV 贴图，在右上角可以观察以绿色编码的高度。可以清楚地看到，车辆的车顶比路面具有更高的强度。在左下方可以看到蓝色的强度。根据屏幕的对比度，或许能够区分尾灯或车牌等物体。在右下方，点云密度以红色显示，可以清楚地看到车辆侧面、前后部显示最多。另外，随着距离的增加，路面上的点密度越来越小，这显然与透视效果和激光雷达的垂直角分辨率有关。

#### 3.3 复合YOLO网络应用于点云BEV鸟瞰图

复合YOLO网络架构如下图所示

![Complex YOLO network architecture](https://qqsj789.github.io/img//sdcnd-c2-3-img4-16328957400794.png)


在原始论文使用了简化的 YOLOv2 CNN 架构。原始 YOLO 网络的扩展是复角回归和欧拉区域提议网络 (E-RPN)，它们用于获取检测到的对象周围的边界框的方向。

YOLO 网络已配置为将图像划分为 16 x 32 网格并预测 75 个特征。该模型共有 18 个卷积层和 5 个池化层，还有 3 个中间层用于特征重组。

YOLO网络预测每个网格有一组固定的框，在这里是5个。对于每个框，获得6个单独的参数，包括二维位置，宽度和长度以及两个方向角度:$\left[x,y,w,l，\alpha_{Im}，\alpha_{Re} \right]$

除了方框参数外，还有一个参数用于指示边界框是否包含实际对象并被准确放置。此外，有三个参数表明一个框是否属于“汽车”、“行人”或“自行车”类。

最后，区域建议网络使用 5 个附加参数来估计准确的对象方向和边界。

#### 3.4 3D边界框盒子重建（3D bounding box re-conversion）

使 Complex YOLO 与众不同的一个方面是经典 Grid RPN 方法的扩展，该方法仅通过方向角估计边界框位置和形状，并将其编码为欧拉符号中的复角（因此得名“E- RPN") 使得方向可以重构为$\mathrm{arctan2}(Im,Re)$。 下图显示了边界框回归过程中估计的参数：

![Bounding box regression parameters](https://qqsj789.github.io/img//sdcnd-c2-3-img5-16328970812656.png)

然后将回归值直接传递给损失函数计算，该函数基于使用多部分损失的 YOLO 概念（即平方误差的总和），但通过欧拉回归部分对其进行扩展，该部分通过计算基本事实和预测角度之间的差异，始终假设在上图所示的圆圈内。

#### 3.5 为什么使用复合YOLO网络?

与其他当前可用的方法相比，复杂 YOLO 网络的主要优势之一是它的速度。从下图可以看出，Complex YOLO 的可实现帧率明显高于PointNet 或 VoxelNet 同时实现类似的检测性能。这使其非常适合自动驾驶汽车等实时应用。

![Complex YOLO performance assessment - showing much higher FPS than similarly performing algorithms](https://qqsj789.github.io/img//sdcnd-c2-3-img6-16328972152498.png)

复杂 YOLO 当前实现的一个缺点是缺乏边界框高度和垂直位置。假设所有边界框都位于路面上，并且根据检测类别将高度设置为预定义的常数。在跟踪阶段，这可能会导致不同海拔的驾驶场景不准确。 

[这篇论文](https://arxiv.org/pdf/1808.02350v1.pdf)描述了 Complex YOLO 的改进版本，将概念扩展到全 3D。

#### 3.6 创建3D点云BEV鸟瞰图


过滤定义区域之外的所有点，从激光雷达点云中删除所有不满足以下条件的点：

$0m≤p_x≥+50m$

$−25m≤p_y≥+25m$

$−1m≤p_z≥+3m$

```python
lim_x = [0,50]
lim_y = [-25,25]
lim_z = [-1, 3]
```

可以使用 np.where 来检索坐标在这些范围内的点：

```python
mask = np.where((lidar_pcl[:, 0] >= lim_x[0]) & (lidar_pcl[:, 0] <= lim_x[1]) &
                (lidar_pcl[:, 1] >= lim_y[0]) & (lidar_pcl[:, 1] <= lim_y[1]) &
                (lidar_pcl[:, 2] >= lim_z[0]) & (lidar_pcl[:, 2] <= lim_z[1]))
lidar_pcl = lidar_pcl[mask]
```

对于预定义的限制，得到的点云如下所示

![Cropped point cloud (large area)](https://qqsj789.github.io/img//c2-3-img7-16329114466552.png)

将限制更改为更严格的设置会立即影响剩余点数，如下图所示

![Cropped point cloud (small area)](https://qqsj789.github.io/img//c2-3-img8-16329114952414.png)

通过将定义的区域划分为单元格并将每个点的公制坐标转换为网格坐标来创建实际的 BEV MAP。以下代码以米/像素为单位提供单个 BEV 单元的尺寸：

```python
bev_width = 608
bev_height = 608
bev_discret = (lim_x[1] - lim_x[0]) / bev_height
```

### 4. 物体对象检测性能评估

在许多论文、排名和挑战（例如 Waymo Open Challenge 或 KITTI 3D Object Detection Benchmark）中，诸如“平均精度”（AP）和“中位平均精度”（mAP）等指标经常被用作事实上的标准比较检测算法。下图展示了Waymo Open Challenge的排行榜：

![Waymo Challenge Leaderboard](https://qqsj789.github.io/img//c2-4-img1-16329139852766.png)

#### 4.1 评估物体对象检测器简介

![Two vehicles in point cloud](https://qqsj789.github.io/img//c2-4-img2-16329140829538-163661131853743.png)

从图像中可以看出，场景中有两辆车。物体对象检测算法需要执行两个主要任务，分别是：

- 判断场景中是否存在物体
- 确定物体的位置、方向和形状

第一个任务称为“分类”，而第二个任务通常称为“定位”。在现实生活场景中，物体检测将包含多个对象类别（例如车辆、行人、骑自行车者、交通标志），需要为每个检测到的对象分配置信度分数，通常在 0.0 和 1.0 之间的范围内。基于这个分数，检测算法可以在不同的置信水平上进行评估，这意味着接受或拒绝对象的阈值是有系统地变化的。

为了解决这些问题，提出了平均精度 (AP) 度量标准作为对象检测的合适度量标准。要理解 AP 背后的概念，需要了解术语“精度”和“召回率”以及四个特征“真阳性”（TP）、“真阴性”（TN）、“假阳性”（FP） 和“假阴性”（FN）。

#### 4.2 TP, TN, FP and FN

再次考虑上一个示例中的点云，现在有一组由对象检测算法添加的边界框：

![True Positive (TP) - a vehicle detected, False Positive (FP) - a non-existent vehicle detected, False Negative (FN) - a vehicle not detected](https://qqsj789.github.io/img//c2-4-img3-163291452300310.png)

标记为“TP”的边界框显示了正确的检测：它包围了一个实际对象，并且形状和方向都是准确的。 这被称为“真阳性”，其中“阳性”表示检测器看到的物体的存在。 在右侧，有一个标记为“FP”的红色边界框，其中不包含任何对象，因此是错误检测。 这种错误的对象被称为“误报”，因为检测器错误地认为存在实际对象。 此外，在图像的底部，点云中有一个清晰可见的物体，但检测器没有发现它。 这种漏检被称为“假阴性”，其中“阴性”意味着检测器相信没有物体。 在对患者进行特定疾病测试的医学试验中，以下内容将成立：

- TP : 病人确实有病，检测结果呈阳性
- FP : 患者没有患病，但检测结果仍为阳性
- FN : 病人有病，但检测结果错误地为阴性

最后，还有一种情况是患者没有患病并且测试正确返回阴性结果。 这被称为“真阴性”（TN）。 在物体检测中，这意味着场景中不存在物体并且检测器没有正确返回检测。 这四种状态可以排列成一个矩阵，在机器学习中称为“混淆矩阵”：

![Confusion matrix - TP is predicted positive and is positive, FP is predicted positive but is not, FN is predicted negative but is positive, and TN is predicted negative and is negative]![](https://qqsj789.github.io/img//sdcnd-c2-4-img4-163291525741612.png)

请注意，预测值与实际值一致的情况位于矩阵的主对角线上。

#### Precision and Recall

想象一下，我们想要以一种有意义的方式评估上面示例中使用的检测算法。 我们可能会问的两个问题可能是：

- 检测算法找到的对象实际上对应于真实对象的概率是多少？
- 检测算法找到真实物体的概率是多少？

让我们尝试根据正例和负例来回答第一个问题：为了得出这个概率，我们需要将真正例除以所有检测的数量，即真正例和假正例的总和。 这个比率被称为“精度”P：
$$
P = \frac{TP}{TP + FP}
$$
在实践中，精度有时也称为“阳性预测值”（PPV）。

对于我们假设的检测器，其精度为$P= \frac{1}{1 +1} =0.5$ ,基于这一次和它的总共两次检测，检测到一个真实物体的概率将是50%。

第二个问题可以用类似的方式回答：为了计算检测到实际物体的概率，我们需要将实际检测的数量除以实际检测和漏检的总和。 被称为“召回”R：
$$
R = \frac{TP}{TP + FN}
$$
在实践中，召回率也常被称为“真阳性率”（TPR）或“敏感度”。

对于我们假设的检测器，召回率将是$R= \frac{1}{1+1} =0.5$  。显然，用这么少的测量值来计算单一帧的这个度量是没有多大意义的。因此，在实践中，精度和召回率是在整个数据集上计算的，并且应该包含来自每个类(TP, TN, FN)的一些代表，以便结果具有统计相关性。

为了有意义地评估检测器的性能，我们必须同时检查精度和召回率。 一个完美的检测器将同时具有 1.0 的召回率和 1.0 的精度。 然而，在实践中，这两种措施通常都处于紧张状态，这意味着提高精度，例如 通过调整一些检测器参数，很可能会降低召回率，反之亦然。 假设我们有一个检测器，它返回以下结果：TP=80，FP=2，FN=6。 根据这些数字，我们将得到：
$$
P = \frac{80}{80+2}=0.9756
$$

$$
R = \frac{80}{80+6}=0.9302
$$

如果我们降低分类阈值，使得置信度得分较低的对象被视为检测，则 FN 的数量会减少，而 FP 的数量会增加，例如 TP=80, FP=6, FN =2。 对于绩效衡量，这意味着

$P = \frac{80}{80+6}=0.9302$ ,      $ R = \frac{80}{80+2}=0.9756$

如您所见，准确率降低，而召回率提高。 在增加分类阈值的情况下，这种效果会逆转。 一般来说，在精度和召回率上都优于另一种算法的检测算法很可能会更好。

另一种基于预测类型的度量称为“准确度”AA，它是正确预测的数量与预测总数的比率。 准确度可以表示为：
$$
A = \frac{TP+TN}{TP+TN+FP+FN}
$$
但是，在对象检测中，不使用准确度，因为真阴性的数量与有意义的检测器行为不对应。 “没有物体并且检测器没有检测到物体”的状态将适用于没有检测和没有物体的场景的所有区域。 在实践中，我们需要一个物体的存在，无论是来自检测器还是来自诸如人类观察者的可信来源，以推导出状态 TP、FP 和 FN。

#### Intersection-over-Union (IoU)

在前面的示例中，我们理所当然地认为某些实体会向我们提供检测是 TP、FP 还是 FN 的信息。 然而在实践中，事情并没有那么容易。 为了将检测分类到这些类别中，需要采取几个步骤：

- 提供一个由人类生成的检测列表，作为检测标准。这种检测通常被称为“标签”。
- 将我们想要评估的算法提供的检测列表与ground-truth label标签列表进行匹配。
- 根据检测与ground-truth label的重叠程度，判断某一检测是TP、FP还是FN。

看看上一示例中的点云，它现在包含检测器生成的边界框（红色）以及真实标签（绿色）。

![Labels (green) vs. detections (red)](https://qqsj789.github.io/img//c2-4-img5-163291798054914.png)

如您所见，车辆 1 的边界框在形状和大小上都非常相似，基于检测的边界框略小于人工标记的边界框。 但是，对于车辆 2，由于形状、比例和角度的差异，两个框之间的重叠要小得多。

但是，为了以有意义的方式评估检测器，我们需要决定是否将真实标签和检测结果视为匹配项。 在实践中，我们使用称为“Intersection-over-Union”（IoU）的度量来决定是否分配两个边界框。 这个想法是测量检测器返回的每个边界框与所有真实边界框之间的重叠程度，以计算两个矩形的交集面积和并集面积。 下图说明了这个概念：

![Intersection-over-Union (IoU) - area of overlap over area of union](https://qqsj789.github.io/img//sdcnd-c2-4-img6-163291809416816.png)

如您所见，检测和真实情况之间的重叠越小，联合交叉点就越小。 如果根本没有重叠，IoU 将为 0.0，而对于完美匹配，IoU 将为 1.0。 在实践中，我们需要在匹配检测和真实标签时为 IoU 确定一个“合适的”阈值。 例如，如果 IoU 阈值为 0.5，并且某个标签检测匹配的 IoU 值为 0.7，那么我们将其归类为 TP。 另一方面，当 IoU 低于阈值时，例如 在 0.3 处，我们将相应的检测分类为 FP。 如果存在根本没有检测到的真实标签，则将它们归类为 FN。

基于 IoU 阈值，精度和召回率的值会发生变化，因为在低阈值下，预计许多检测将与标签匹配，从而导致大量 TP。 在大多数基准测试（例如 KITTI、Waymo）中，车辆所需的最小 IoU 为 70%。 但在我们进一步研究改变 IoU 的想法之前，让我们先看看精度-召回曲线的概念，这是我们计算检测器“平均精度”的下一步。

#### Precision-Recall Curve

如前所述，准确率和召回率之间存在反比关系，这取决于我们为对象检测选择的阈值。 让我们看看下图，它展示了各种物体检测算法的精度-召回曲线（每种颜色代表不同的算法）：

![Precision-Recall curves for 5 detectors, with some variance along the curves](https://qqsj789.github.io/img//sdcnd-c2-4-img7-163291830418218.png)

这些曲线是通过将检测阈值从 0.0 变化到 1.0 并计算每个设置的精度和召回率来生成的。 基于此指标，蓝色实线曲线显示最佳性能，因为精度（即检测实际上对应于真实对象的可能性）随着召回值的增加而下降的最少。 理想情况下，精度将保持在 1.0，直到达到 1.0 的召回率。 因此，查看这些曲线的另一种方法是根据曲线下的面积比较检测器：因此，精确召回曲线的积分越大，检测器的性能就越高。 基于精度-召回曲线，工程师可以通过考虑应用在精度和召回方面的需求，就他们想要选择的检测器阈值设置做出明智的决定。

#### Average Precision

平均精度 (AP) 度量的思想是将精度-召回曲线内的信息压缩为一个数字，可用于轻松地相互比较算法。 这个目标是通过对不同 (=11) 等距召回值的精度值求和来实现的：
$$
AP=\frac{1}{11}\sum_{\mathrm{Recall}_i} \mathrm{Precision}(\mathrm{Recall}_i)
$$
下图进一步说明了该概念：

![Average precision is calculated across the whole curve](https://qqsj789.github.io/img//c2-4-img8-163291856008220.png)

请注意，在实践中，以等间距增量改变阈值水平并不对应于等间距增加的召回率。 算法的 AP 分数在 0.0 和 1.0 之间变化，后者是一个完美的结果。

#### Mean Average Precision (mAP)

现在，您已经了解了精确回忆曲线的形状是如何被压缩成一个简单的数字以便进行比较的，我们可以采取最后一步，并增加一个更复杂的层次:基于对IoU阈值变化对精度和召回率都有影响的观察，mAP方法的思想是计算各种IoU阈值的AP分数，然后从这些值计算平均值。下图显示了几种IoU阈值设置的精度召回曲线。

![Precision-Recall curves for varying IoU thresholds, with large differences among them](https://qqsj789.github.io/img//sdcnd-c2-4-img9-163291875655722.png)

可以看出，随着IoU阈值的降低，曲线的形状趋于矩形。

此外，一些排名站点不仅考虑 IoU 阈值，还考虑各种对象类别。 例如，在 PASCAL VOC 2007 挑战赛中，只考虑了一个 IoU 设置 (0.5) 和 20 个对象类。 另一方面，在 COCO 2017 挑战赛中，mAP 平均超过 10 个 IoU 设置和 80 个对象类别。

## [回首页](../index.html)